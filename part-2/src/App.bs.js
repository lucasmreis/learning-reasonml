// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as List                     from "bs-platform/lib/es6/list.js";
import * as $$Array                  from "bs-platform/lib/es6/array.js";
import * as Block                    from "bs-platform/lib/es6/block.js";
import * as Curry                    from "bs-platform/lib/es6/curry.js";
import * as React                    from "react";
import * as Js_boolean               from "bs-platform/lib/es6/js_boolean.js";
import * as Pervasives               from "bs-platform/lib/es6/pervasives.js";
import * as Json_decode              from "@glennsl/bs-json/src/Json_decode.bs.js";
import * as ReasonReact              from "reason-react/src/ReasonReact.js";
import * as CardContainer$SimpleDeck from "./components/Card/CardContainer.bs.js";

import './App.css'
;

function decodeCreatedDeck(json) {
  return /* record */[
          /* deckId */Json_decode.field("deck_id", Json_decode.string, json),
          /* remaining */Json_decode.field("remaining", Json_decode.$$int, json),
          /* cards : [] */0
        ];
}

function createDeckSideEffects(self) {
  fetch("https://deckofcardsapi.com/api/deck/new/shuffle/").then((function (prim) {
                return prim.json();
              })).then((function (json) {
              return Promise.resolve(decodeCreatedDeck(json));
            })).then((function (deck) {
            return Promise.resolve(Curry._1(self[/* send */4], /* DeckCreated */Block.__(0, [deck])));
          })).catch((function () {
          return Promise.resolve(Curry._1(self[/* send */4], /* CreateDeckFailed */1));
        }));
  return /* () */0;
}

function decodeCard(json) {
  return /* record */[
          /* image */Json_decode.field("image", Json_decode.string, json),
          /* code */Json_decode.field("code", Json_decode.string, json)
        ];
}

function decodeDeck(json) {
  return /* record */[
          /* deckId */Json_decode.field("deck_id", Json_decode.string, json),
          /* remaining */Json_decode.field("remaining", Json_decode.$$int, json),
          /* cards */Json_decode.field("cards", (function (param) {
                  return Json_decode.list(decodeCard, param);
                }), json)
        ];
}

function drawnOrFinished(current, received) {
  if (received[/* remaining */1] > 0) {
    return /* CardsDrawn */Block.__(2, [/* record */[
                /* deckId */received[/* deckId */0],
                /* remaining */received[/* remaining */1],
                /* cards */Pervasives.$at(current[/* cards */2], received[/* cards */2])
              ]]);
  } else {
    return /* DeckFinished */Block.__(3, [current[/* cards */2]]);
  }
}

function drawQuantity(deck) {
  return Pervasives.min(deck[/* remaining */1], 3).toString();
}

function drawCardsSideEffects(currentDeck, self) {
  fetch("https://deckofcardsapi.com/api/deck/" + (currentDeck[/* deckId */0] + ("/draw/?count=" + drawQuantity(currentDeck)))).then((function (prim) {
              return prim.json();
            })).then((function (json) {
            return Promise.resolve(decodeDeck(json));
          })).then((function (receivedDeck) {
          return Promise.resolve(Curry._1(self[/* send */4], drawnOrFinished(currentDeck, receivedDeck)));
        }));
  return /* () */0;
}

function reducer(action, _) {
  if (typeof action === "number") {
    switch (action) {
      case 0 : 
          return /* UpdateWithSideEffects */Block.__(3, [
                    /* CreatingDeck */0,
                    createDeckSideEffects
                  ]);
      case 1 : 
      case 2 : 
          return /* Update */Block.__(0, [/* Error */1]);
      
    }
  } else {
    switch (action.tag | 0) {
      case 1 : 
          var currentDeck = action[0];
          return /* UpdateWithSideEffects */Block.__(3, [
                    /* DrawingCards */Block.__(1, [currentDeck]),
                    (function (param) {
                        return drawCardsSideEffects(currentDeck, param);
                      })
                  ]);
      case 0 : 
      case 2 : 
          return /* Update */Block.__(0, [/* WaitingForUser */Block.__(0, [action[0]])]);
      case 3 : 
          return /* Update */Block.__(0, [/* NoMoreCardsToDraw */Block.__(2, [action[0]])]);
      
    }
  }
}

function renderParagraph(text) {
  return React.createElement("p", undefined, text);
}

function renderLoading() {
  return renderParagraph("Loading...");
}

function renderError() {
  return renderParagraph("There was an error. Please refresh and try again!");
}

function renderCards(cards) {
  var cardElements = $$Array.of_list(List.map((function (c) {
              return ReasonReact.element(/* None */0, /* None */0, CardContainer$SimpleDeck.make(c[/* code */1], c[/* image */0], /* array */[]));
            }), cards));
  return React.createElement("div", {
              className: "App card-list"
            }, cardElements);
}

function renderButtonAndCards(deck, send, disabledButton) {
  return React.createElement("div", {
              className: "App"
            }, React.createElement("button", {
                  className: "App main-action",
                  disabled: Js_boolean.to_js_boolean(disabledButton),
                  onClick: (function () {
                      return Curry._1(send, /* DrawCards */Block.__(1, [deck]));
                    })
                }, "Draw " + drawQuantity(deck)), renderCards(deck[/* cards */2]));
}

function render(self) {
  var match = self[/* state */2];
  var tmp;
  if (typeof match === "number") {
    tmp = match ? renderParagraph("There was an error. Please refresh and try again!") : renderParagraph("Loading...");
  } else {
    switch (match.tag | 0) {
      case 0 : 
          tmp = renderButtonAndCards(match[0], self[/* send */4], /* false */0);
          break;
      case 1 : 
          tmp = renderButtonAndCards(match[0], self[/* send */4], /* true */1);
          break;
      case 2 : 
          tmp = renderCards(match[0]);
          break;
      
    }
  }
  return React.createElement("div", {
              className: "App"
            }, tmp);
}

var component = ReasonReact.reducerComponent("App");

function make() {
  var newrecord = component.slice();
  newrecord[/* didMount */4] = (function (self) {
      Curry._1(self[/* send */4], /* CreateDeck */0);
      return /* NoUpdate */0;
    });
  newrecord[/* render */9] = render;
  newrecord[/* initialState */10] = (function () {
      return /* CreatingDeck */0;
    });
  newrecord[/* reducer */12] = reducer;
  return newrecord;
}

var $$default = ReasonReact.wrapReasonForJs(component, (function () {
        return make(/* array */[]);
      }));

var number_of_cards_per_draw = 3;

export {
  decodeCreatedDeck        ,
  createDeckSideEffects    ,
  decodeCard               ,
  decodeDeck               ,
  drawnOrFinished          ,
  number_of_cards_per_draw ,
  drawQuantity             ,
  drawCardsSideEffects     ,
  reducer                  ,
  renderParagraph          ,
  renderLoading            ,
  renderError              ,
  renderCards              ,
  renderButtonAndCards     ,
  render                   ,
  component                ,
  make                     ,
  $$default                ,
  $$default                  as default,
  
}
/*  Not a pure module */
